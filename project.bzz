ALPHA = 1
BETA = 1
MAPSIZE = 10
ROBOTS = 5
SCALE = 160
SP = 0.02
INFINITY = 1000000
SENSORSCALE = 100

function table1D(x, val) {
	var t = {}
	
	var i = 0
	while(i < x) {
    t[i] = val
		i = i + 1
	}
	return t
}

function table2D(x, y, val) {
	var t = {}

	var i = 0
	while(i < x) {
		t[i] = table1D(y, val)
		i = i + 1
	}
	return t
}

function setupQueue() {
	var queue = {}

	var i = 0
	while(i < ROBOTS) {
		queue[i] = 0.0
		i = i + 1
	}
	return queue
}

function getNeighborLocations() {
	# Transform Distance/Azimuth to Cartesian Coordinates
	cart = neighbors.map(
		function(rid, data) {
			var c = {}
			c.x = data.distance * math.cos(data.azimuth)
			c.y = data.distance * math.sin(data.azimuth)
			return c })
	return cart
}

function getWorldBlock(pos) {
	# Map Floating Point Value to Discrete Grid
	var idx = (-MAPSIZE / 2)
	while (idx < MAPSIZE) {
		var lower = ((idx * SCALE) ^ 1)
		var upper = (((idx + 1) * SCALE) ^ 1)
		if (pos > lower and pos <= upper) {
			return (idx + (MAPSIZE / 2))
		}
		
		idx = idx + 1
	}
	return -1
}

function getWorldCoordinate(pos) {
	return ((pos - (MAPSIZE/2)) * SCALE) + (SCALE / 2)
}

function encodeXY(x,y) {
	return (x * MAPSIZE) + y
}

function decodeX(val) {
	return (val / MAPSIZE)
}

function decodeY(val) {
	return (val % MAPSIZE)
}

function getFrontierCells() {
	marked = {}

	var idx = 0
	while(idx < size(locs)) {
		idx = idx + 1
		dfsSearch(locs[idx].x, locs[idx].y)
	}
}

function dfsSearch(x, y) {
	# Check if Cell Has Been Checked
	var code = encodeXY(x,y)
	if (marked[code] != nil)
		return
	marked[code] = 1

	# Check For Unexplored Neighbors
	if (x > 0) { if (g_map[x-1][y] == 0) {
		frontier[encodeXY(x-1,y)] = 1
	}}
	if (y > 0) { if (g_map[x][y-1] == 0) {
		frontier[encodeXY(x,y-1)] = 1
	}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 0) {
		frontier[encodeXY(x+1,y)] = 1
	}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 0) {
		frontier[encodeXY(x,y+1)] = 1
	}}

	# Check For Explored Neighbors
	if (x > 0) { if (g_map[x-1][y] == 1) {
		dfsSearch(x-1, y, map)
	}}
	if (y > 0) { if (g_map[x][y-1] == 1) {
		dfsSearch(x, y-1, map)
	}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 1) {
		dfsSearch(x+1, y, map)
	}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 1) {
		dfsSearch(x, y+1, map)
	}}
}

function getTravelCost() {
	var idx = 1
	while (idx < ROBOTS) {
		pos = locs[idx]

		# Value Iteration: Initialize All Cells (except start) to INFINITY
		vi = table2D(MAPSIZE, MAPSIZE, INFINITY)
		vi[pos.x][pos.y] = 0

		# Perform DP Search
		dpSearch(pos.x, pos.y)

		# Copy Frontier & Map Values to 'cost'
		cost[idx] = {}
		foreach(g_map, function(key, value) {
			foreach(value, function(key2, value2) {
				if (value2 == 1) {
					cost[idx][encodeXY(key,key2)] = vi[key][key2]
				}
			})
		})
		foreach(frontier, function(key, value) {
			cost[idx][key] = vi[decodeX(key)][decodeY(key)]
		})
		
		idx = idx + 1
	}
}

function dpSearch(x, y) {
	var score = vi[x][y] + 1

	# Check All Neighbors for Score Improvements
	if (x > 0) { if (g_map[x-1][y] == 1 or frontier[encodeXY(x-1,y)] == 1) { if (score < vi[x-1][y]) {
		vi[x-1][y] = score
		dpSearch(x-1, y)
	}}}
	if (y > 0) { if (g_map[x][y-1] == 1 or frontier[encodeXY(x,y-1)] == 1) { if (score < vi[x][y-1]) {
		vi[x][y-1] = score
		dpSearch(x, y-1)
	}}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 1 or frontier[encodeXY(x+1,y)] == 1) { if (score < vi[x+1][y]) {
		vi[x+1][y] = score
		dpSearch(x+1, y)
	}}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 1 or frontier[encodeXY(x,y+1)] == 1) { if (score < vi[x][y+1]) {
		vi[x][y+1] = score
		dpSearch(x, y+1)
	}}}
}

function gradientDescentSearch(step, robotIdx, curIdx, goalIdx, cost) {
	# Recursion Base Case
	if (curIdx == goalIdx)
		return

	if (step > 10) {
		log("FAIL!!!! (step>",step,")")
		outlineBlocks()
		halt()
	}

	# Store Path
	var x = decodeX(curIdx)
	var y = decodeY(curIdx)
	subgoals[robotIdx][step] = curIdx

	# Find Best Direction
	var minIdx = -1
	var minVal = INFINITY
	if (x > 0) { if (cost[robotIdx][encodeXY(x-1,y)] != nil and cost[robotIdx][encodeXY(x-1,y)] < minVal) {
		minVal = cost[robotIdx][encodeXY(x-1,y)]
		minIdx = encodeXY(x-1,y)
	}}
	if (y > 0) { if (cost[robotIdx][encodeXY(x,y-1)] != nil and cost[robotIdx][encodeXY(x,y-1)] < minVal) {
		minVal = cost[robotIdx][encodeXY(x,y-1)]
		minIdx = encodeXY(x,y-1)
	}}
	if (x < MAPSIZE-1) { if (cost[robotIdx][encodeXY(x+1,y)] != nil and cost[robotIdx][encodeXY(x+1,y)] < minVal) {
		minVal = cost[robotIdx][encodeXY(x+1,y)]
		minIdx = encodeXY(x+1,y)
	}}
	if (y < MAPSIZE-1) { if (cost[robotIdx][encodeXY(x,y+1)] != nil and cost[robotIdx][encodeXY(x,y+1)] < minVal) {
		minVal = cost[robotIdx][encodeXY(x,y+1)]
		minIdx = encodeXY(x,y+1)
	}}

	# Recurse
	gradientDescentSearch(step+1, robotIdx, minIdx, goalIdx, cost)
}

function outlineBlocks() {
	var offset = (SCALE / 2) ^ 1
	var color = {.r = 0, .g = 0, .b = 255}
	foreach(g_map, function(key, value) {
		var xC = getWorldCoordinate(key) ^ 1
		foreach(value, function(key2, value2) {
			var yC = getWorldCoordinate(key2) ^ 1
			if (value2 == 1) {
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC - offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC + offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
			}
		})
	})


	color = {.r = 0, .g = 255, .b = 0}
	foreach(goals, function(key, value) {
		if (value != -1) {
			var xC = getWorldCoordinate(decodeX(value)) ^ 1
			var yC = getWorldCoordinate(decodeY(value)) ^ 1

			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0,
				(xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
		}
	})

	color = {.r = 255, .g = 0, .b = 0}
	foreach(frontier, function(key, value) {
		var xC = getWorldCoordinate(decodeX(key)) ^ 1
		var yC = getWorldCoordinate(decodeY(key)) ^ 1

		debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0,
			(xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0)
		debug.rays.add(color.r, color.g, color.b, (xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
			(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
		debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
			(xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0)
		debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0, 
			(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
	})
}

#################################################
### BUZZ FUNCTIONS ##############################
#################################################

# Executed at init time
function init() {
	myswarm = swarm.create(1)
	myswarm.join()

	# Initialize Map & Instruction Queue
	if (id == 0) {
		g_map = table2D(MAPSIZE, MAPSIZE, 0)
		goals = table1D(ROBOTS, -1)
		subgoals = table2D(ROBOTS, 0, -1)
		unassignedCount = ROBOTS - 1
		frontier = {}
	}

	# Setup Debug Options
	debug.trajectory.enable(100)
}

# Executed every time step
function step() {

	# Master Coordinates Motion
	if (id == 0) {
		outlineBlocks()

		# Retrieve Each Robot Location
		neighbor_locs = getNeighborLocations()
		locs = {}

		# Iterate Over Robots
		var robot = 1
		while (robot < ROBOTS) {

			# Transform Continuous Position to Discrete Grid
			var xPos = neighbor_locs.data[robot].x
			var yPos = neighbor_locs.data[robot].y
			xPos = getWorldBlock(xPos)
			yPos = getWorldBlock(yPos)

			# Mark Current Cell as Visited
			if (xPos >= 0 and yPos >= 0 and xPos < MAPSIZE and yPos < MAPSIZE) {	
				g_map[xPos][yPos] = 1

				# Handle Subgoal Reached
				if (encodeXY(xPos, yPos) == subgoals[robot][size(subgoals[robot])-1]) {
					subgoals[robot][size(subgoals[robot])-1] = nil

					# Handle Goal Reached
					if (encodeXY(xPos, yPos) == goals[robot]) {
						log("Robot (id=",robot,") reached goal (id=",goals[robot],")")
						goals[robot] = -1
						subgoals[robot] = {}
						unassignedCount = unassignedCount + 1
					}
				}

				# Handle Other Robot's Goal Reached
				foreach(goals, function(key, value) {
					if (encodeXY(xPos, yPos) == goals[key]) {
						log("FRIENDLYFIRE!!!")
						goals[key] = -1
						subgoals[key] = {}
						unassignedCount = unassignedCount + 1
					}
				})
			}

			# Store Position in Simple Table
			locs[robot] = {.x = xPos, .y = yPos}
			robot = robot + 1
		}

		# Only Plan if Some Robots Need Assignments
		if (unassignedCount > 0) {

			# Get Table of Frontier Cells
			frontier = {}
			getFrontierCells()
			#log("Computed Frontier: ", frontier)

			# Compute Travel Cost From Each Robot to Each Frontier Cell (V_t^i)
			cost = {}
			getTravelCost()
			#log("Computed Cost: ", cost)

			# Remove Already Assigned Frontier Cells
			var idx = 1
			while(idx < ROBOTS) {
				if (goals[idx] != -1 and frontier[goals[idx]] != nil) {
					frontier[goals[idx]] = nil
				}
				idx = idx + 1
			}

			# Match 1 Robot to a Frontier Cell
			idx = 0
			maxUtil = -INFINITY
			robotIdx = -1
			frontierIdx = -1

			# Iterate Through All Robots
			var iter = 1
			while(iter < ROBOTS) {

				# Iterate Through All Frontier Cells
				foreach(frontier, function(k, v) {
					var lag = (ALPHA * v) - (BETA * cost[iter][k])

					# Save Optimal Choice
					if (lag > maxUtil and goals[iter] == -1) {
						maxUtil = lag
						robotIdx = iter
						frontierIdx = k
					}
				})
				iter = iter + 1
			}

			# Derive Plan from Steepest Gradient Descent
			if (robotIdx != -1) {
				log("Robot (id=",robotIdx,") starting goal (id=",frontierIdx,")")
				subgoals[robotIdx] = {}
				var curIdx = encodeXY(locs[robotIdx].x, locs[robotIdx].y)
				gradientDescentSearch(0, robotIdx, frontierIdx, curIdx, cost)
			}

			# Finalize Decision
			goals[robotIdx] = frontierIdx
			frontier[frontierIdx] = nil
			unassignedCount = unassignedCount - 1
			idx = idx + 1
		}
	
		# Send Commands to Each Robot
		idx = 1
		while(idx < ROBOTS) {
			var goal = subgoals[idx][size(subgoals[idx])-1]
			if (goal != nil) {
				var dX = getWorldCoordinate(decodeX(goal)) - neighbor_locs.data[idx].x
				var dY = getWorldCoordinate(decodeY(goal)) - neighbor_locs.data[idx].y

				var target = {.x = dX, .y = dY, .goal = goals[idx]}
				neighbors.broadcast(string.tostring(idx), target)
			}
			idx = idx + 1
		}
		debug.print("(controller)")
	}

	# Slaves Read From Instruction Queue
	else {
		neighbors.listen(string.tostring(id),
			function(vid, value, rid) {
				goto(value.x, value.y)
				debug.print("(",decodeX(value.goal),",",decodeY(value.goal),")")
			}
		)
	}
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}

# Execute at exit
function destroy() {
}
