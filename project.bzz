ALPHA = 1
BETA = 1
MAPSIZE = 10
ROBOTS = 5
SCALE = 160
SP = 0.02
INFINITY = 1000000
SENSORSCALE = 100

function table1D(x, val) {
	var t = {}
	
	var i = 0
	while(i < x) {
    t[i] = val
		i = i + 1
	}
	return t
}

function table2D(x, y, val) {
	var t = {}

	var i = 0
	while(i < x) {
		t[i] = table1D(y, val)
		i = i + 1
	}
	return t
}

function setupQueue() {
	var queue = {}

	var i = 0
	while(i < ROBOTS) {
		queue[i] = 0.0
		i = i + 1
	}
	return queue
}

function getNeighborLocations() {
	# Transform Distance/Azimuth to Cartesian Coordinates
	cart = neighbors.map(
		function(rid, data) {
			var c = {}
			c.x = data.distance * math.cos(data.azimuth)
			c.y = data.distance * math.sin(data.azimuth)
			return c })
	return cart
}

function getWorldBlock(pos) {
	# Map Floating Point Value to Discrete Grid
	var idx = (-MAPSIZE / 2)
	while (idx < MAPSIZE) {
		var lower = ((idx * SCALE) ^ 1)
		var upper = (((idx + 1) * SCALE) ^ 1)
		if (pos > lower and pos <= upper) {
			return (idx + (MAPSIZE / 2))
		}
		
		idx = idx + 1
	}
	return -1
}

function getWorldCoordinate(pos) {
	return ((pos - (MAPSIZE/2)) * SCALE) + (SCALE / 2)
}

function encodeXY(x,y) {
	return (x * MAPSIZE) + y
}

function decodeX(val) {
	return (val / MAPSIZE)
}

function decodeY(val) {
	return (val % MAPSIZE)
}

function getFrontierCells() {
	marked = {}

	var idx = 0
	while(idx < size(locs)) {
		idx = idx + 1
		searchAndRecurse(locs[idx].x, locs[idx].y)
	}
}

function searchAndRecurse(x, y) {
	# Check if Cell Has Been Checked
	var code = encodeXY(x,y)
	if (marked[code] != nil)
		return
	marked[code] = 1

	# Check For Unexplored Neighbors
	if (x > 0) { if (g_map[x-1][y] == 0) {
		frontier[encodeXY(x-1,y)] = 1
	}}
	if (y > 0) { if (g_map[x][y-1] == 0) {
		frontier[encodeXY(x,y-1)] = 1
	}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 0) {
		frontier[encodeXY(x+1,y)] = 1
	}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 0) {
		frontier[encodeXY(x,y+1)] = 1
	}}

	# Check For Explored Neighbors
	if (x > 0) { if (g_map[x-1][y] == 1) {
		searchAndRecurse(x-1, y, map)
	}}
	if (y > 0) { if (g_map[x][y-1] == 1) {
		searchAndRecurse(x, y-1, map)
	}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 1) {
		searchAndRecurse(x+1, y, map)
	}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 1) {
		searchAndRecurse(x, y+1, map)
	}}
}

function getTravelCost() {
	var idx = 1
	while (idx < ROBOTS) {
		pos = locs[idx]

		# Value Iteration: Initialize All Cells (except start) to INFINITY
		vi = table2D(MAPSIZE, MAPSIZE, INFINITY)
		vi[pos.x][pos.y] = 0

		# Perform DP Search
		dpSearch(pos.x, pos.y)

		# Copy Frontier Values to 'cost'
		cost[idx] = {}
		foreach(frontier, function(key, value) {
			cost[idx][key] = vi[decodeX(key)][decodeY(key)]
		})
		idx = idx + 1
	}
}

function dpSearch(x, y) {
	var score = vi[x][y] + 1

	# Check All Neighbors for Score Improvements
	if (x > 0) { if (g_map[x-1][y] == 1 or frontier[encodeXY(x-1,y)] == 1) { if (score < vi[x-1][y]) {
		vi[x-1][y] = score
		dpSearch(x-1, y)
	}}}
	if (y > 0) { if (g_map[x][y-1] == 1 or frontier[encodeXY(x,y-1)] == 1) { if (score < vi[x][y-1]) {
		vi[x][y-1] = score
		dpSearch(x, y-1)
	}}}
	if (x < MAPSIZE-1) { if (g_map[x+1][y] == 1 or frontier[encodeXY(x+1,y)] == 1) { if (score < vi[x+1][y]) {
		vi[x+1][y] = score
		dpSearch(x+1, y)
	}}}
	if (y < MAPSIZE-1) { if (g_map[x][y+1] == 1 or frontier[encodeXY(x,y+1)] == 1) { if (score < vi[x][y+1]) {
		vi[x][y+1] = score
		dpSearch(x, y+1)
	}}}
}

function outlineBlocks() {
	var offset = (SCALE / 2) ^ 1
	var color = {.r = 0, .g = 0, .b = 255}
	foreach(g_map, function(key, value) {
		var xC = getWorldCoordinate(key) ^ 1
		foreach(value, function(key2, value2) {
			var yC = getWorldCoordinate(key2) ^ 1
			if (value2 == 1) {
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC - offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC + offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC - offset) / SENSORSCALE, 0.0)
				debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0, 
					(xC + offset) / SENSORSCALE, (yC + offset) / SENSORSCALE, 0.0)
			}
		})
	})


	color = {.r = 0, .g = 255, .b = 0}
	foreach(goals, function(key, value) {
		if (value != -1) {
			var xC = getWorldCoordinate(decodeX(value)) ^ 1
			var yC = getWorldCoordinate(decodeY(value)) ^ 1

			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0,
				(xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC - offset) / SENSORSCALE + SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC - offset) / SENSORSCALE + SP, 0.0)
			debug.rays.add(color.r, color.g, color.b, (xC - offset) / SENSORSCALE + SP, (yC + offset) / SENSORSCALE - SP, 0.0, 
				(xC + offset) / SENSORSCALE - SP, (yC + offset) / SENSORSCALE - SP, 0.0)
		}
	})
}

#################################################
### BUZZ FUNCTIONS ##############################
#################################################

# Executed at init time
function init() {
	reset()
	myswarm = swarm.create(1)
	myswarm.join()

	# Initialize Map & Instruction Queue
	if (id == 0) {
		g_map = table2D(MAPSIZE, MAPSIZE, 0)
		goals = table1D(ROBOTS, -1)
		unassignedCount = ROBOTS - 1
	}

	# Setup Debug Options
	debug.trajectory.enable(10000)
}

# Executed every time step
function step() {

	# Master Coordinates Motion
	if (id == 0) {
		outlineBlocks()

		# Retrieve Each Robot Location
		neighbor_locs = getNeighborLocations()
		locs = {}

		# Iterate Over Robots
		var robot = 1
		while (robot < ROBOTS) {

			# Transform Continuous Position to Discrete Grid
			var xPos = neighbor_locs.data[robot].x
			var yPos = neighbor_locs.data[robot].y
			xPos = getWorldBlock(xPos)
			yPos = getWorldBlock(yPos)

			# Mark Current Cell as Visited
			if (xPos >= 0 and yPos >= 0 and xPos < MAPSIZE and yPos < MAPSIZE) {	
				g_map[xPos][yPos] = 1

				# Handle Goal Reached
				if (encodeXY(xPos, yPos) == goals[robot]) {
					log("Robot (id=",robot,") reached goal (id=",goals[robot],")")
					goals[robot] = -1
					unassignedCount = unassignedCount + 1
				}
			}

			# Store Position in Simple Table
			locs[robot] = {.x = xPos, .y = yPos}
			robot = robot + 1
		}

		# Only Plan if Some Robots Need Assignments
		if (unassignedCount > 0) {

			# Get Table of Frontier Cells
			frontier = {}
			getFrontierCells()
			#log("Computed Frontier: ", frontier)

			# Compute Travel Cost From Each Robot to Each Frontier Cell (V_t^i)
			cost = {}
			getTravelCost()
			#log("Computed Cost: ", cost)

			# Remove Already Assigned Frontier Cells
			var idx = 1
			while(idx < ROBOTS) {
				if (goals[idx] != -1 and frontier[goals[idx]] != nil) {
					frontier[goals[idx]] = nil
				}
				idx = idx + 1
			}

			# Match Robots to Frontier Cells
			idx = 0
			while(idx < unassignedCount) {
				maxUtil = -INFINITY
				robotIdx = -1
				frontierIdx = -1

				# Iterate Through All Robots
				var iter = 1
				while(iter < ROBOTS) {
				
					# Iterate Through All Frontier Cells
					foreach(frontier, function(key, value) {
						var lag = (ALPHA * value) - (BETA * cost[iter][key])

						# Save Optimal Choice
						if (lag > maxUtil and goals[iter] == -1) {
							maxUtil = lag
							robotIdx = iter
							frontierIdx = key
						}
					})
					iter = iter + 1
				}

				log("Robot (id=",robotIdx,") starting goal (id=",frontierIdx,")")
				goals[robotIdx] = frontierIdx
				frontier[frontierIdx] = nil
				unassignedCount = unassignedCount - 1
				idx = idx + 1
			}
		}
	
		# Send Commands to Each Robot
		idx = 1
		while(idx < ROBOTS) {
			var dX = getWorldCoordinate(decodeX(goals[idx])) - neighbor_locs.data[idx].x
			var dY = getWorldCoordinate(decodeY(goals[idx])) - neighbor_locs.data[idx].y

			var target = {.x = dX, .y = dY, .goal = goals[idx]}
			neighbors.broadcast(string.tostring(idx), target)
			idx = idx + 1
		}
	}

	# Slaves Read From Instruction Queue
	else {
		neighbors.listen(string.tostring(id),
			function(vid, value, rid) {
				goto(value.x, value.y)
				debug.print(value.goal)
			}
		)
	}
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}

# Execute at exit
function destroy() {
}
